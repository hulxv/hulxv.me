---
title: "Mill-io: Architecture in Depth"
description: Talk about mill-io architecture in depth
draft: true
date: 2025-8-27
---

The event loop we built contains several components inside it, and we will discuss them one by one.

```mermaid
graph TB
    subgraph "Application Layer"
        A1[User Code] --> A2[EventHandler Implementation]
        A2 --> A3[EventLoop API]
    end

    subgraph "Mill-IO Core"
        A3 --> B1[Reactor]
        B1 --> B2[PollHandle]
        B1 --> B3[ThreadPool]
        B2 --> B4[Handler Registry]
    end

    subgraph "System Layer"
        B2 --> C1[mio::Poll]
        C1 --> C2[OS Polling]
        C2 --> C3[epoll/kqueue/IOCP]
    end

    subgraph "Memory Management"
        B3 --> D1[ObjectPool]
        D1 --> D2[Buffer Recycling]
    end
```

## 1. PollHandle, the I/O Polling Abstraction

In this component, we use the [mio-rs](https://github.com/tokio-rs/mio) library as a cross-platform backend to deal with and manage event notifications. It uses OS interfaces such as `epoll` for Linux, `kqueue` for macOS, and `IOCP` for Windows.

> mio-rs: Mio is a fast, low-level I/O library for Rust focusing on non-blocking APIs and event notification for building high-performance I/O apps with as little overhead as possible over the OS abstractions.

```mermaid
graph TD
    A[PollHandle] --> B[mio::Poll]
    A --> C[Handler Registry]
    A --> D[Waker]

    B --> E[Platform Polling]
    C --> F[Token â†’ Handler Mapping]
    D --> G[External Wake Events]
```

This component wraps `mio::Poll` with better handler management and maps each event to its handler to execute when it's ready. It basically sends a system call to the OS (such as `epoll` for Linux, as we said above) that means, "Hey Mr. OS! Wake me up when this I/O operation on this file is ready to be handled!" From it, you can let the OS notify you when a specific file/socket is available to read, write, or both.

You can register the events you want with their handlers, as in the following example:

```rust
let poller = PollHandle::new().unwrap();
let mut src = TestSource::new();

struct NoopHandler;
impl EventHandler for NoopHandler {
    fn handle_event(&self, _event: &mio::event::Event) {
        println!("Handling the Noop event...");
    }
}

poller
    .register(&mut src, mio::Token(1), mio::Interest::READABLE, NoopHandler)
    .expect("Failed to register src");
```

You can also deregister them and poll the events.

## 2. ThreadPool - Task Executor

After polling the events and the OS waking us up, we need to execute the handlers. The thread pool is similar to the `thread-per-connection` or `thread-per-task` model, but it limits the number of workers (threads) to reduce context-switching operations.

```mermaid
flowchart TD
    A[ThreadPool] --> B[Channel Sender]
    B --> C[Shared Receiver]

    C --> D[Worker 1]
    C --> E[Worker 2]
    C --> F[Worker N]

    D --> G[Task Execution]
    E --> G
    F --> G
```

We can run a specific task as follows:

```rust
let pool = ThreadPool::new(4);
let counter = Arc::new(AtomicUsize::new(0));

for _ in 0..10 {
    let counter_clone = counter.clone();
    pool.exec(move || {
        counter_clone.fetch_add(1, Ordering::SeqCst);
    })
    .unwrap();
}
```

The pool will let an available worker finish this job in an individual thread by sending it through a message passing channel (we use a multi-producer, single-consumer channel because a standard multi-producer, multi-consumer channel isn't yet in the standard library and would require a third-party crate or an unstable feature). The thread will then execute this job.

## 3. Reactor - The Event Orchestration

It's a simple component that contains the thread pool and the poll handler to poll the events and dispatch them to the thread pool to execute their handlers. This design is what event loops are based on.

```mermaid
flowchart LR
    A[Reactor] --> B[Poll Events]
    B --> C[Dispatch to ThreadPool]
    C --> D[Execute Handlers]
    D --> B

    A --> E[Shutdown Signal]
    E --> F[Graceful Stop]
```

> The reactor software design pattern is an event handling strategy that can respond to many potential service requests concurrently. The pattern's key component is an event loop, running in a single thread or process, which demultiplexes incoming requests and dispatches them to the correct request handler.
> **Read more:** https://en.wikipedia.org/wiki/Reactor_pattern

## 4. EventLoop - The Public API

To work with the library, you don't need to deal with all the previous technical components. We provide a simple interface to use it by simply registering/deregistering events and running the event loop. It also allows you to shut it down.
It manages the lifecycle of the `Reactor`. It starts by polling for events and waiting for the OS to tell it when those events have occurred. When that happens, the handler will be executed.

```mermaid
sequenceDiagram
    participant App as Application
    participant EL as EventLoop
    participant R as Reactor
    participant PH as PollHandle
    participant TP as ThreadPool
    participant H as Handler

    App->>EL: register(source, token, handler)
    EL->>R: poll_handle.register()
    R->>PH: register with mio + store handler

    Note over R: Main event loop
    loop Event Loop
        R->>PH: poll(events, timeout)
        PH->>R: return event count

        loop For each event
            R->>TP: dispatch_event(event)
            TP->>H: handle_event(event)
            H-->>TP: processing complete
        end
    end

    App->>EL: stop()
    EL->>R: shutdown_handle.shutdown()
    R->>PH: wake()
    Note over R: Exit event loop
```

